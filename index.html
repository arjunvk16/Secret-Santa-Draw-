<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Santa Draw</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Custom Christmas colors */
        .bg-christmas-red { background-color: #990000; }
        .text-christmas-red { color: #990000; }
        .bg-christmas-green { background-color: #006633; }
        .text-christmas-green { color: #006633; }
        .bg-gold { background-color: #ffd700; }
        .text-gold { color: #ffd700; }

        /* Animation for the spinning effect */
        @keyframes spin-text {
            0% { transform: translateY(0); opacity: 1; }
            5% { transform: translateY(-50px); opacity: 0; }
            10% { transform: translateY(50px); opacity: 0; }
            15% { transform: translateY(0); opacity: 1; }
            /* Repeat cycles for a few seconds */
            100% { transform: translateY(0); opacity: 1; }
        }
        .spinning {
            animation: spin-text 0.1s infinite cubic-bezier(0.42, 0, 0.58, 1);
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app-container" class="w-full max-w-lg bg-white shadow-2xl rounded-xl p-8 transition-all duration-300">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-christmas-red mb-2">Secret Santa Draw üéÅ</h1>
            <p class="text-gray-600" id="header-subtitle">Secure Draw - Firebase Auth</p>
        </header>

        <!-- Loading Indicator -->
        <div id="loading-indicator" class="hidden text-center p-4">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-christmas-green inline-block"></div>
            <p class="mt-2 text-christmas-green">Loading authentication and draw state...</p>
        </div>

        <!-- Enrollment/Setup Area (Visible only for administrators or un-enrolled users) -->
        <div id="enrollment-area" class="space-y-4 p-6 bg-red-100 text-red-800 rounded-lg shadow-md hidden">
            <h2 class="text-xl font-bold">Enrollment Required</h2>
            <p class="text-sm">Please select your name to link it to your unique user account. **DO NOT** select another person's name!</p>
            <div id="enrollment-form">
                <select id="enrollment-select" class="block w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:border-red-500 focus:ring focus:ring-red-500 focus:ring-opacity-50 transition duration-150 text-lg">
                    <option value="" disabled selected>Select Your Name</option>
                </select>
                <button id="enroll-button" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 disabled:opacity-50">
                    Enroll Account
                </button>
            </div>
            <div id="enrollment-status" class="text-sm font-semibold mt-2 hidden"></div>
        </div>
        
        <!-- Main Content Area (Visible only when authenticated and enrolled) -->
        <div id="main-content" class="space-y-6 hidden">

            <!-- Step 1: User Identity -->
            <div id="user-identity-area" class="bg-gray-50 p-4 rounded-lg shadow-inner text-center">
                <h2 id="welcome-message" class="text-2xl font-bold text-christmas-green mb-1"></h2>
                <p id="auth-status" class="text-sm mt-2 text-gray-500"></p>
            </div>

            <!-- Step 2: Spin and Result -->
            <div id="spin-area" class="p-6 rounded-lg border-2 border-dashed border-gold/50 text-center">
                <button id="spin-button" class="w-full bg-christmas-red hover:bg-christmas-green text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-xl" disabled>
                    Start the Draw!
                </button>

                <div id="result-box" class="mt-8 p-6 bg-christmas-green rounded-lg shadow-xl hidden">
                    <p class="text-white text-xl font-semibold">You are buying a gift for:</p>
                    <div class="my-4">
                        <span id="target-name-display" class="text-6xl font-extrabold text-gold block leading-tight tracking-wider">???</span>
                    </div>
                    <p class="text-white text-sm opacity-80">Keep the secret safe!</p>
                </div>

                <div id="already-drawn-message" class="mt-8 p-4 bg-yellow-100 text-yellow-800 rounded-lg shadow-md hidden">
                    <p class="font-semibold">You have already drawn your Secret Santa!</p>
                    <p class="text-sm mt-1">Please check the result box above.</p>
                </div>
            </div>

            <!-- List of Participants (Always Visible) -->
            <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                <p class="text-sm font-semibold text-christmas-green mb-2">Enrolled Participants (9 Total):</p>
                <ul id="participant-list" class="flex flex-wrap gap-2 text-sm text-gray-700">
                    <!-- Names will be listed here -->
                </ul>
            </div>
            
            <!-- Admin Controls -->
            <div class="pt-4 border-t border-gray-200 space-y-3">
                <button id="reset-button" class="w-full text-xs text-gray-500 hover:text-red-500 transition duration-150 p-2 rounded-lg border border-gray-300 hover:border-red-500" disabled>
                    [Admin] Reset All Data
                </button>
            </div>
        </div>
        
        <!-- General Message Box -->
        <div id="message-box" class="mt-4 p-3 rounded-lg text-sm text-center hidden"></div>
    </div>

    <script type="module">
        // Mandatory Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, runTransaction, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Enable Firestore Debug Logging
        setLogLevel('Debug');

        // Global Canvas Variables (MANDATORY TO USE)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Security Constant (Secret Key for client-side encryption) ---
        const SECRET_KEY = appId + "_XMAS2025_V2"; 
        
        // --- Firebase Setup ---
        let app, db, auth, userId = null;
        
        // The core participant list
        const ALL_PARTICIPANTS = ["Arjun", "Alvin", "Shany", "Adarsh", "Gokul", "Vismaya", "Amal", "Aswin", "Ambady"];
        
        // --- Identity Management ---
        let currentDrawerName = null; // Name of the participant associated with the current userId
        
        // Initial public data structure
        const initialPublicData = {
            participants: ALL_PARTICIPANTS,
            // Maps Firebase UID to participant name, used for enrollment tracking
            user_name_map: {}, 
            // List of participant names that have been assigned as targets (publicly visible)
            targets_assigned: [], 
        };

        let currentDrawState = {
            user_name_map: {},
            targets_assigned: [],
        };

        const elements = {
            loading: document.getElementById('loading-indicator'),
            mainContent: document.getElementById('main-content'),
            enrollmentArea: document.getElementById('enrollment-area'),
            enrollmentSelect: document.getElementById('enrollment-select'),
            enrollButton: document.getElementById('enroll-button'),
            enrollmentStatus: document.getElementById('enrollment-status'),
            messageBox: document.getElementById('message-box'),
            welcomeMessage: document.getElementById('welcome-message'),
            spinButton: document.getElementById('spin-button'),
            resultBox: document.getElementById('result-box'),
            targetNameDisplay: document.getElementById('target-name-display'),
            participantList: document.getElementById('participant-list'),
            alreadyDrawnMessage: document.getElementById('already-drawn-message'),
            authStatus: document.getElementById('auth-status'),
            resetButton: document.getElementById('reset-button'),
        };

        // --- Paths ---
        function getPublicDocRef() {
            // Public data path: /artifacts/{appId}/public/data/christmas_exchange/gift_exchange_public
            return doc(db, 'artifacts', appId, 'public', 'data', 'christmas_exchange', 'gift_exchange_public');
        }
        
        function getPrivateAssignmentDocRef(uid) {
            // Private data path: /artifacts/{appId}/users/{userId}/secret_santa/assignment
            return doc(db, 'artifacts', appId, 'users', uid, 'secret_santa', 'assignment');
        }

        // --- Encryption/Decryption Functions (XOR Cipher) ---
        function xorEncrypt(text, key) {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                result += String.fromCharCode(charCode);
            }
            return btoa(result); 
        }

        function xorDecrypt(encryptedText, key) {
            try {
                const decodedText = atob(encryptedText);
                let result = '';
                for (let i = 0; i < decodedText.length; i++) {
                    const charCode = decodedText.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                    result += String.fromCharCode(charCode);
                }
                return result;
            } catch (e) {
                console.error("Decryption failed:", e);
                return "DECRYPTION_FAILED";
            }
        }
        // -----------------------------------------------------

        function showMessage(text, isError = false) {
            elements.messageBox.textContent = text;
            elements.messageBox.className = `mt-4 p-3 rounded-lg text-sm text-center ${isError ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`;
            elements.messageBox.style.display = 'block';
        }

        function hideMessage() {
            elements.messageBox.style.display = 'none';
        }
        
        function populateEnrollmentDropdown(enrolledNames) {
            elements.enrollmentSelect.innerHTML = '<option value="" disabled selected>Select Your Name</option>';
            
            // Only show names that have NOT been enrolled yet
            const enrolledValues = Object.values(enrolledNames);
            const availableNames = ALL_PARTICIPANTS.filter(name => !enrolledValues.includes(name));

            availableNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                elements.enrollmentSelect.appendChild(option);
            });
            
            elements.enrollButton.disabled = elements.enrollmentSelect.value === "";
        }

        function updateParticipantList() {
            const enrolledNames = Object.values(currentDrawState.user_name_map);
            elements.participantList.innerHTML = ALL_PARTICIPANTS.map(name => {
                const isEnrolled = enrolledNames.includes(name);
                const drawnClass = currentDrawState.targets_assigned.includes(name) ? 'bg-yellow-200 text-yellow-800' : 'bg-christmas-green/10 text-christmas-green';
                const baseClass = isEnrolled ? drawnClass : 'bg-gray-300 text-gray-600';
                
                return `<li class="px-3 py-1 ${baseClass} rounded-full text-xs font-medium">${name} ${isEnrolled ? '' : '(Pending Enrollment)'}</li>`;
            }).join('');
        }

        async function initializeFirebase() {
            elements.loading.classList.remove('hidden');
            
            if (!firebaseConfig.apiKey) {
                showMessage("Firebase configuration is missing or invalid. Cannot initialize the app.", true);
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                // Auth
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                userId = auth.currentUser.uid;
                
                elements.authStatus.textContent = "Your Account ID: " + userId;
                console.log("Firebase initialized. User ID:", userId);

                // Start listening for public and private data
                setupRealtimeListeners();

            } catch (error) {
                console.error("Error during Firebase initialization or authentication:", error);
                showMessage(`Authentication failed: ${error.message}. Check console for details.`, true);
            }
        }
        
        // --- Data Listeners ---
        function setupRealtimeListeners() {
            const publicRef = getPublicDocRef();
            const privateRef = getPrivateAssignmentDocRef(userId);

            // 1. Listen to Public Draw State
            onSnapshot(publicRef, (docSnap) => {
                if (docSnap.exists()) {
                    currentDrawState = docSnap.data();
                    console.log("Public state updated:", currentDrawState);
                } else {
                    console.log("Public state missing. Initializing...");
                    setDoc(publicRef, initialPublicData);
                    currentDrawState = initialPublicData;
                }
                // Update UI based on public state (enrollment status, participant list)
                handlePublicStateUpdate();
            }, (error) => {
                console.error("Firestore public listen failed:", error);
                showMessage("Real-time data synchronization failed.", true);
            });
            
            // 2. Listen to Private Assignment (only visible to current user)
            onSnapshot(privateRef, (docSnap) => {
                if (docSnap.exists() && currentDrawerName) {
                    const data = docSnap.data();
                    handlePrivateStateUpdate(data);
                } else if (!docSnap.exists() && currentDrawerName) {
                    // User is enrolled but hasn't drawn yet
                    handlePrivateStateUpdate({});
                }
            }, (error) => {
                console.error("Firestore private listen failed:", error);
                // This is normal if security rules prevent access for an unauthenticated user
            });
        }
        
        function handlePublicStateUpdate() {
            elements.loading.classList.add('hidden');
            
            const map = currentDrawState.user_name_map || {};
            const enrolledUsers = Object.keys(map);
            currentDrawerName = map[userId] || null;

            updateParticipantList();

            if (currentDrawerName) {
                // User is enrolled - show main content
                elements.enrollmentArea.classList.add('hidden');
                elements.mainContent.classList.remove('hidden');
                elements.welcomeMessage.textContent = `Welcome, ${currentDrawerName}!`;
            } else {
                // User is NOT enrolled - show enrollment area
                elements.enrollmentArea.classList.remove('hidden');
                elements.mainContent.classList.add('hidden');
                populateEnrollmentDropdown(map);
            }
            
            // Admin button control
            elements.resetButton.disabled = currentDrawState.targets_assigned.length > 0;
        }

        function handlePrivateStateUpdate(privateData) {
            // This runs after public state ensures currentDrawerName is set
            if (!currentDrawerName) return; 

            const encryptedTarget = privateData.target;
            
            if (encryptedTarget) {
                // Already drawn
                const target = xorDecrypt(encryptedTarget, SECRET_KEY);
                
                if (target === "DECRYPTION_FAILED") {
                    showMessage("Error: Failed to retrieve your secret assignment. Please contact admin.", true);
                    return;
                }

                showResult(target);
                elements.alreadyDrawnMessage.classList.remove('hidden');
                elements.spinButton.textContent = "Drawing Complete";
                elements.spinButton.disabled = true;
            } else {
                // Needs to draw
                elements.resultBox.classList.add('hidden');
                elements.alreadyDrawnMessage.classList.add('hidden');
                
                elements.spinButton.textContent = "Draw Your Secret Santa!";
                // Enable button only if enrolled AND assignment is not set
                elements.spinButton.disabled = !currentDrawerName; 
            }
        }

        function showResult(targetName) {
            elements.targetNameDisplay.textContent = targetName;
            elements.resultBox.classList.remove('hidden');
        }
        
        // --- Enrollment Logic ---
        elements.enrollmentSelect.addEventListener('change', () => {
            elements.enrollButton.disabled = elements.enrollmentSelect.value === "";
        });

        elements.enrollButton.addEventListener('click', async () => {
            const selectedName = elements.enrollmentSelect.value;
            if (!selectedName || !userId) {
                showMessage("Please select a name and ensure you are logged in.", true);
                return;
            }
            
            elements.enrollButton.disabled = true;
            elements.enrollmentStatus.classList.remove('hidden');
            elements.enrollmentStatus.textContent = `Enrolling ${selectedName}...`;

            try {
                // 1. Update the public map
                const publicRef = getPublicDocRef();
                await updateDoc(publicRef, { 
                    user_name_map: {
                        ...currentDrawState.user_name_map,
                        [userId]: selectedName
                    }
                });
                
                // 2. Set the local name (listener will handle UI update)
                currentDrawerName = selectedName;
                showMessage(`Successfully enrolled as ${selectedName}! You can now draw.`, false);

            } catch (error) {
                console.error("Enrollment failed:", error);
                showMessage("Failed to save enrollment data.", true);
            } finally {
                elements.enrollButton.disabled = false;
                elements.enrollmentStatus.classList.add('hidden');
            }
        });

        // --- Draw Logic ---
        async function spinAndAssign() {
            const drawerName = currentDrawerName;
            if (!drawerName) {
                showMessage("Please enroll your account first.", true);
                return;
            }

            elements.spinButton.disabled = true;
            hideMessage();
            
            // --- Draw Logic (Protected by Transaction) ---
            const publicRef = getPublicDocRef();
            const privateRef = getPrivateAssignmentDocRef(userId);

            try {
                const targetName = await runTransaction(db, async (transaction) => {
                    const publicSnap = await transaction.get(publicRef);
                    if (!publicSnap.exists()) {
                        throw new Error("Draw data document does not exist. Please refresh.");
                    }
                    
                    const publicData = publicSnap.data();
                    const targetsAssigned = publicData.targets_assigned || [];

                    // Check if already drawn (based on private doc, which is not done here for security)
                    // We rely on the UI state, but add a robust check here against the target array size
                    
                    // Determine available targets: ALL_PARTICIPANTS - targets_assigned - drawerName
                    const availableTargets = ALL_PARTICIPANTS.filter(
                        name => name !== drawerName && !targetsAssigned.includes(name)
                    );

                    if (availableTargets.length === 0) {
                        throw new Error("Assignment pool is empty or corrupted. Cannot draw.");
                    }

                    // 1. Randomly select the target
                    const randomIndex = Math.floor(Math.random() * availableTargets.length);
                    const newTargetName = availableTargets[randomIndex];
                    
                    // 2. Encrypt the target name
                    const encryptedTarget = xorEncrypt(newTargetName, SECRET_KEY);

                    // 3. Update the public document: Mark the target as taken
                    transaction.update(publicRef, {
                        targets_assigned: [...targetsAssigned, newTargetName],
                    });
                    
                    // 4. Create/Update the private assignment document: Store the encrypted target
                    transaction.set(privateRef, { 
                        target: encryptedTarget,
                        drawer: drawerName,
                        drawn_at: Date.now()
                    });

                    return newTargetName;
                });

                // If transaction is successful, run animation
                animateSpin(targetName);

            } catch (error) {
                console.error("Transaction failed:", error);
                let message = "Failed to complete the draw.";
                if (error.message.includes("Assignment pool is empty")) {
                    message = "Assignment pool error: Unable to find a valid recipient.";
                }
                showMessage(message, true);
                elements.spinButton.disabled = false;
            }
        }
        
        function animateSpin(targetName) {
            elements.targetNameDisplay.textContent = ALL_PARTICIPANTS[0];
            elements.resultBox.classList.remove('hidden');
            elements.spinButton.textContent = "Drawing...";
            
            // Visual spin effect
            elements.targetNameDisplay.classList.add('spinning');

            const SPIN_DURATION_MS = 3000;
            const start = Date.now();
            
            const interval = setInterval(() => {
                const elapsed = Date.now() - start;
                
                if (elapsed < SPIN_DURATION_MS) {
                    // Update text with a random name from all participants
                    const randomIndex = Math.floor(Math.random() * ALL_PARTICIPANTS.length);
                    elements.targetNameDisplay.textContent = ALL_PARTICIPANTS[randomIndex];
                } else {
                    // End the spin
                    clearInterval(interval);
                    elements.targetNameDisplay.classList.remove('spinning');
                    showResult(targetName);
                    
                    // onSnapshot listener will update UI based on successful save
                }
            }, 100);
        }
        
        // --- Admin Functionality ---
        async function resetDraw() {
            // Using custom modal replacement for confirm()
            if (!confirm("Are you sure you want to completely reset the Secret Santa draw? This will erase ALL ENROLLMENTS and ALL ASSIGNMENTS.")) {
                return; 
            }

            elements.resetButton.disabled = true;
            try {
                // 1. Reset Public Data
                await setDoc(getPublicDocRef(), initialPublicData);
                
                // NOTE: We rely on security rules to prevent reading/writing other users' private data.
                // Resetting the public data is enough, as the new draw will overwrite the old map.
                showMessage("The Secret Santa draw has been successfully reset! All users must re-enroll.", false);

            } catch (error) {
                console.error("Error resetting draw:", error);
                showMessage("Failed to reset the draw in Firestore.", true);
            } finally {
                // onSnapshot will re-enable the button if the reset was successful
            }
        }

        // --- Event Listeners ---
        elements.spinButton.addEventListener('click', spinAndAssign);
        elements.resetButton.addEventListener('click', resetDraw);

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeFirebase();
        });

    </script>
</body>
</html>
