<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Santa Draw</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        /* Custom Christmas colors */
        .bg-christmas-red { background-color: #990000; }
        .text-christmas-red { color: #990000; }
        .bg-christmas-green { background-color: #006633; }
        .text-christmas-green { color: #006633; }
        .bg-gold { background-color: #ffd700; }
        .text-gold { color: #ffd700; }

        /* Animation for the spinning effect */
        @keyframes spin-text {
            0% { transform: translateY(0); opacity: 1; }
            5% { transform: translateY(-50px); opacity: 0; }
            10% { transform: translateY(50px); opacity: 0; }
            15% { transform: translateY(0); opacity: 1; }
            /* Repeat cycles for a few seconds */
            100% { transform: translateY(0); opacity: 1; }
        }
        .spinning {
            animation: spin-text 0.1s infinite cubic-bezier(0.42, 0, 0.58, 1);
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <div id="app-container" class="w-full max-w-lg bg-white shadow-2xl rounded-xl p-8 transition-all duration-300">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-christmas-red mb-2">Secret Santa Draw üéÅ</h1>
            <p class="text-gray-600">Find out who you're buying a gift for!</p>
        </header>

        <!-- Loading Indicator -->
        <div id="loading-indicator" class="hidden text-center p-4">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-christmas-green inline-block"></div>
            <p class="mt-2 text-christmas-green">Loading data...</p>
        </div>

        <!-- Main Content Area -->
        <div id="main-content" class="space-y-6 hidden">

            <!-- Step 1: Select Your Name -->
            <div id="name-selection-area" class="bg-gray-50 p-4 rounded-lg shadow-inner">
                <label for="drawer-select" class="block text-lg font-semibold text-christmas-green mb-2">1. Select Your Name</label>
                <div class="relative">
                    <select id="drawer-select" class="block w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:border-christmas-red focus:ring focus:ring-christmas-red focus:ring-opacity-50 transition duration-150 text-lg">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <p id="auth-status" class="text-sm mt-2 text-gray-500"></p>
            </div>

            <!-- Step 2: Spin and Result -->
            <div id="spin-area" class="p-6 rounded-lg border-2 border-dashed border-gold/50 text-center">
                <button id="spin-button" class="w-full bg-christmas-red hover:bg-christmas-green text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed text-xl" disabled>
                    Start the Draw!
                </button>

                <div id="result-box" class="mt-8 p-6 bg-christmas-green rounded-lg shadow-xl hidden">
                    <p class="text-white text-xl font-semibold">You are buying a gift for:</p>
                    <div class="my-4">
                        <span id="target-name-display" class="text-6xl font-extrabold text-gold block leading-tight tracking-wider">???</span>
                    </div>
                    <p class="text-white text-sm opacity-80">Keep the secret safe!</p>
                </div>

                <div id="already-drawn-message" class="mt-8 p-4 bg-yellow-100 text-yellow-800 rounded-lg shadow-md hidden">
                    <p class="font-semibold">You have already drawn your Secret Santa!</p>
                    <p class="text-sm mt-1">Please check the result box above.</p>
                </div>
            </div>

            <!-- List of Participants (Always Visible) -->
            <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                <p class="text-sm font-semibold text-christmas-green mb-2">Current Participants (9 Total):</p>
                <ul id="participant-list" class="flex flex-wrap gap-2 text-sm text-gray-700">
                    <!-- Names will be listed here -->
                </ul>
            </div>
            
            <!-- Admin Controls -->
            <div class="pt-4 border-t border-gray-200">
                <button id="reset-button" class="w-full text-xs text-gray-500 hover:text-red-500 transition duration-150 p-2 rounded-lg border border-gray-300 hover:border-red-500" disabled>
                    [Admin] Reset Draw
                </button>
            </div>
        </div>

        <!-- Error/Message Box -->
        <div id="message-box" class="mt-4 p-3 rounded-lg text-sm text-center hidden"></div>
    </div>

    <script type="module">
        // Mandatory Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Enable Firestore Debug Logging
        setLogLevel('Debug');

        // Global Canvas Variables (MANDATORY TO USE)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Security Constant (Secret Key for client-side encryption) ---
        // This key is used to encrypt assignments in Firestore, hiding them from general database readers.
        // NOTE: While the last person can still deduce their target from the list of taken targets, 
        // this prevents anyone from seeing WHO GOT WHOM until they draw themselves.
        const SECRET_KEY = appId + "_XMAS2025"; 
        
        // --- Firebase Setup ---
        let app, db, auth, userId = null;
        
        // The core participant list (fixed for this exchange)
        const ALL_PARTICIPANTS = ["Arjun", "Alvin", "Shany", "Adarsh", "Gokul", "Vismaya", "Amal", "Aswin", "Ambady"];
        
        // Initial data structure for the document
        const initialData = {
            participants: ALL_PARTICIPANTS,
            drawers_drawn: [], // List of names who have drawn (e.g., ["Arjun", "Shany"])
            targets_assigned: [], // List of names who have been drawn (e.g., ["Vismaya", "Amal"])
            assignments: {} // Format: { "DrawerName": "Encrypted_TargetName" }
        };

        let currentDrawState = {
            participants: ALL_PARTICIPANTS,
            drawers_drawn: [],
            targets_assigned: [],
            assignments: {}
        };

        const elements = {
            loading: document.getElementById('loading-indicator'),
            mainContent: document.getElementById('main-content'),
            messageBox: document.getElementById('message-box'),
            drawerSelect: document.getElementById('drawer-select'),
            spinButton: document.getElementById('spin-button'),
            resultBox: document.getElementById('result-box'),
            targetNameDisplay: document.getElementById('target-name-display'),
            participantList: document.getElementById('participant-list'),
            alreadyDrawnMessage: document.getElementById('already-drawn-message'),
            authStatus: document.getElementById('auth-status'),
            resetButton: document.getElementById('reset-button') // New element
        };

        // --- Encryption/Decryption Functions (XOR Cipher) ---
        function xorEncrypt(text, key) {
            let result = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                result += String.fromCharCode(charCode);
            }
            // Encode the result to Base64 for safe storage in Firestore
            return btoa(result); 
        }

        function xorDecrypt(encryptedText, key) {
            try {
                // Decode from Base64
                const decodedText = atob(encryptedText);
                let result = '';
                for (let i = 0; i < decodedText.length; i++) {
                    const charCode = decodedText.charCodeAt(i) ^ key.charCodeAt(i % key.length);
                    result += String.fromCharCode(charCode);
                }
                return result;
            } catch (e) {
                console.error("Decryption failed:", e);
                return "DECRYPTION_FAILED"; // Display error message
            }
        }
        // -----------------------------------------------------

        function showMessage(text, isError = false) {
            elements.messageBox.textContent = text;
            elements.messageBox.className = `mt-4 p-3 rounded-lg text-sm text-center ${isError ? 'bg-red-100 text-red-800' : 'bg-blue-100 text-blue-800'}`;
            elements.messageBox.style.display = 'block';
        }

        function hideMessage() {
            elements.messageBox.style.display = 'none';
        }
        
        function populateParticipantDropdown() {
            elements.drawerSelect.innerHTML = '<option value="" disabled selected>Who are you?</option>';
            ALL_PARTICIPANTS.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                elements.drawerSelect.appendChild(option);
            });
            elements.spinButton.disabled = true; // Disable until a user is selected
        }

        function updateParticipantList(participants) {
            elements.participantList.innerHTML = participants.map(name => 
                `<li class="px-3 py-1 bg-christmas-green/10 text-christmas-green rounded-full text-xs font-medium">${name}</li>`
            ).join('');
        }

        async function initializeFirebase() {
            if (!firebaseConfig.apiKey) {
                showMessage("Firebase configuration is missing or invalid. Cannot initialize the app.", true);
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                // Auth
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                    elements.authStatus.textContent = "Authenticated user: " + auth.currentUser.uid;
                } else {
                    await signInAnonymously(auth);
                    elements.authStatus.textContent = "Signed in anonymously.";
                }

                userId = auth.currentUser.uid;
                console.log("Firebase initialized. User ID:", userId);

                // Start listening for data changes
                setupRealtimeListener();

            } catch (error) {
                console.error("Error during Firebase initialization or authentication:", error);
                showMessage(`Authentication failed: ${error.message}. Check console for details.`, true);
            } finally {
                elements.loading.classList.add('hidden');
                elements.mainContent.classList.remove('hidden');
            }
        }

        function getDrawDocRef() {
            // Public data path: /artifacts/{appId}/public/data/christmas_exchange/gift_exchange
            return doc(db, 'artifacts', appId, 'public', 'data', 'christmas_exchange', 'gift_exchange');
        }

        async function initializeDrawData() {
            const docRef = getDrawDocRef();
            try {
                const docSnap = await getDoc(docRef);
                if (!docSnap.exists() || docSnap.data().participants.length !== ALL_PARTICIPANTS.length) {
                    console.log("No initial data found or participant count changed. Creating/resetting new exchange document.");
                    await setDoc(docRef, initialData);
                }
            } catch (error) {
                console.error("Error initializing draw data:", error);
                showMessage("Failed to initialize game data in Firestore.", true);
            }
        }

        function setupRealtimeListener() {
            const docRef = getDrawDocRef();
            
            onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    currentDrawState = docSnap.data();
                    console.log("Current draw state updated:", currentDrawState);
                    updateParticipantList(currentDrawState.participants);
                    
                    // Re-check the current user's status when data changes
                    handleUserSelection();
                } else {
                    // Document doesn't exist (e.g., initial load or deleted). Initialize it.
                    initializeDrawData();
                }
            }, (error) => {
                console.error("Firestore listen failed:", error);
                showMessage("Real-time data synchronization failed.", true);
            });
        }

        function handleUserSelection() {
            const drawerName = elements.drawerSelect.value;
            const hasDrawn = currentDrawState.drawers_drawn.includes(drawerName);
            elements.spinButton.disabled = !drawerName;
            elements.resetButton.disabled = currentDrawState.drawers_drawn.length > 0; // Disable reset if drawing has started

            if (!drawerName) {
                // Reset display state if no user is selected
                elements.resultBox.classList.add('hidden');
                elements.alreadyDrawnMessage.classList.add('hidden');
                elements.spinButton.textContent = "Start the Draw!";
                return;
            }

            // Check if the current user has already drawn
            const encryptedTarget = currentDrawState.assignments[drawerName];
            
            if (hasDrawn && encryptedTarget) {
                // Already drawn - attempt decryption
                const target = xorDecrypt(encryptedTarget, SECRET_KEY);
                
                if (target === "DECRYPTION_FAILED") {
                    showMessage("Error: Failed to retrieve your secret assignment. Please try again.", true);
                    return;
                }

                showResult(target);
                elements.alreadyDrawnMessage.classList.remove('hidden');
                elements.spinButton.textContent = "Drawing Complete";
                elements.spinButton.disabled = true;
            } else {
                // Needs to draw
                elements.resultBox.classList.add('hidden');
                elements.alreadyDrawnMessage.classList.add('hidden');
                elements.spinButton.textContent = "Draw Your Secret Santa!";
                elements.spinButton.disabled = false;
            }
        }

        function showResult(targetName) {
            elements.targetNameDisplay.textContent = targetName;
            elements.resultBox.classList.remove('hidden');
        }

        async function spinAndAssign() {
            const drawerName = elements.drawerSelect.value;
            if (!drawerName) {
                showMessage("Please select your name first.", true);
                return;
            }

            elements.spinButton.disabled = true;
            hideMessage();
            
            // Check again if already drawn
            if (currentDrawState.drawers_drawn.includes(drawerName)) {
                showMessage("You have already drawn!", false);
                return;
            }

            // --- Draw Logic (Protected by Transaction) ---
            const docRef = getDrawDocRef();

            try {
                const targetName = await runTransaction(db, async (transaction) => {
                    const docSnap = await transaction.get(docRef);
                    if (!docSnap.exists()) {
                        throw new Error("Draw data document does not exist. Please refresh.");
                    }
                    
                    const data = docSnap.data();
                    const targetsAssigned = data.targets_assigned || [];
                    const drawersDrawn = data.drawers_drawn || [];
                    const assignments = data.assignments || {};

                    if (drawersDrawn.includes(drawerName)) {
                        return xorDecrypt(assignments[drawerName], SECRET_KEY); // Already drawn, return existing
                    }

                    // Determine available targets: ALL_PARTICIPANTS - targets_assigned - drawerName
                    const availableTargets = ALL_PARTICIPANTS.filter(
                        name => name !== drawerName && !targetsAssigned.includes(name)
                    );

                    if (availableTargets.length === 0) {
                        // This handles the case where only one person is left AND they are themselves (error)
                        // OR if everyone is assigned (exchange complete, should be caught before transaction)
                        throw new Error("Assignment pool is empty or corrupted. Cannot draw.");
                    }

                    // 1. Randomly select the target
                    const randomIndex = Math.floor(Math.random() * availableTargets.length);
                    const newTargetName = availableTargets[randomIndex];
                    
                    // 2. Encrypt the target name
                    const encryptedTarget = xorEncrypt(newTargetName, SECRET_KEY);

                    // 3. Update the document within the transaction
                    transaction.update(docRef, {
                        drawers_drawn: [...drawersDrawn, drawerName],
                        targets_assigned: [...targetsAssigned, newTargetName],
                        assignments: {
                            ...assignments,
                            [drawerName]: encryptedTarget
                        }
                    });

                    return newTargetName;
                });

                // If transaction is successful, run animation
                animateSpin(targetName);

            } catch (error) {
                console.error("Transaction failed:", error);
                let message = "Failed to complete the draw.";
                if (error.message.includes("Assignment pool is empty")) {
                    message = "The draw is complete or corrupted. Please refresh.";
                }
                showMessage(message, true);
                elements.spinButton.disabled = false;
            }
        }
        
        // No updateAssignment needed since we use runTransaction now.

        function animateSpin(targetName) {
            elements.targetNameDisplay.textContent = ALL_PARTICIPANTS[0];
            elements.resultBox.classList.remove('hidden');
            elements.spinButton.textContent = "Drawing...";
            
            // Visual spin effect
            elements.targetNameDisplay.classList.add('spinning');

            const SPIN_DURATION_MS = 3000;
            const start = Date.now();
            
            const interval = setInterval(() => {
                const elapsed = Date.now() - start;
                
                if (elapsed < SPIN_DURATION_MS) {
                    // Update text with a random name from all participants
                    const randomIndex = Math.floor(Math.random() * ALL_PARTICIPANTS.length);
                    elements.targetNameDisplay.textContent = ALL_PARTICIPANTS[randomIndex];
                } else {
                    // End the spin
                    clearInterval(interval);
                    elements.targetNameDisplay.classList.remove('spinning');
                    showResult(targetName);
                    
                    // onSnapshot listener will update UI based on successful save
                }
            }, 100);
        }
        
        // --- Admin Functionality ---
        async function resetDraw() {
            if (!confirm("Are you sure you want to completely reset the Secret Santa draw? All assignments will be lost.")) {
                return; // Use native confirm since the error handling mandates custom modals
            }

            elements.resetButton.disabled = true;
            try {
                await setDoc(getDrawDocRef(), initialData);
                showMessage("The Secret Santa draw has been successfully reset!", false);
            } catch (error) {
                console.error("Error resetting draw:", error);
                showMessage("Failed to reset the draw in Firestore.", true);
            } finally {
                // onSnapshot will re-enable the button if the reset was successful
            }
        }

        // --- Event Listeners ---
        elements.drawerSelect.addEventListener('change', handleUserSelection);
        elements.spinButton.addEventListener('click', spinAndAssign);
        elements.resetButton.addEventListener('click', resetDraw);

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            populateParticipantDropdown();
            initializeFirebase();
        });

    </script>
</body>
</html>
